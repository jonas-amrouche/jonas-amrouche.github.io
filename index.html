<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Notable&display=swap" rel="stylesheet">
    <link rel="icon" type="image/svg+xml" href="/src/favicon.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Jonas Amrouche</title>
  </head>
  <body>
    <h1 id="loading-text">LOADING...</h1>
    <canvas id="bg"></canvas>

    <a id="infosContainer">
      <div class="project-container" id="Firelive">
        <h1 class="project-title">Firelive :</h1>
        <p class="project-text">The idea for this project was to make a software for <strong>live mixing</strong> and <strong>live producing</strong> with <strong>integrated loop buffers</strong>, <strong>entirely customizable</strong> and <strong>usable with any custom controllers</strong>.
          <br><br>
          It's not completed as it lacks lots of features I have in mind, but the basics are there.
          <br><br>
          I made the first working version in 1 week and used it in a little 30 mintue set, and it was quite fun.
          I made it with Godot Engine to iterate fast on the UI side, and to use the Godot Audio Engine.
          After the first week I refactored all my code, fix some bugs, polished some features, and start working on a C++ gdextension for all the computing intensive task, like generating the audio spectrum or adding additional audio effect.
          <br>
          <img src="src/zebra.jpg"></img>
          <br><br>
          Before Firelive I had already developped a little application game called <strong>Firestage</strong>.
          <br><br>
          <img src="src/zebra.jpg"></img>
          <br>
          It's a VJing app, not as advanced, where you can mess with light, smokes, fire and laser in front of a crowd, it's not really advanced, as it was supposed to be customizable, but it's fun to play.
          <br><br>
          I love live shows, lightning and audio techniques that hyped up a crowd, and I hope I can one day work on something like that.
        </p>
      </div>
    </a>
    <a id="toggleSoundButton"></a>
    <a id="infoButton"></a>
    <p style="visibility: hidden;" id="tunnelVertexShader">
      uniform float uTime;

      varying vec3 vPosition;
      varying vec3 vNormal;

      float random (in vec2 st) {
        return fract(sin(dot(st.xy,
                            vec2(12.9898,78.233)))
                    * 43758.5453123);
      }
      float noise (in vec2 st) {
        vec2 i = floor(st);
        vec2 f = fract(st);

        // Four corners in 2D of a tile
        float a = random(i);
        float b = random(i + vec2(1.0, 0.0));
        float c = random(i + vec2(0.0, 1.0));
        float d = random(i + vec2(1.0, 1.0));

        // Smooth Interpolation

        // Cubic Hermine Curve.  Same as SmoothStep()
        vec2 u = f*f*(3.0-2.0*f);
        // u = smoothstep(0.,1.,f);

        // Mix 4 coorners percentages
        return mix(a, b, u.x) +
                (c - a)* u.y * (1.0 - u.x) +
                (d - b) * u.x * u.y;
    }

    void main(){
        float noise1 = noise(position.yz * 4.0 + (uTime * vec2(0.3, 1.2)));
        float noise2 = noise(position.yz * 2.0 + (uTime * vec2(-0.9, -0.3)));
        vec3 newPosition = position - normal * noise1 * noise2 * 1.0;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );
        vNormal = normal;
        vPosition = newPosition;
    }
    </p>
    <p style="visibility: hidden;" id="tunnelFragmentShader">
      uniform float uTime;
      uniform float uOpacity;
      
      varying vec3 vPosition;
      varying vec3 vNormal;

      const vec3 cColor = vec3(1.0, 1.0, 1.0);
      
      void main(){
        vec3 depthColor = cColor * clamp(distance(vPosition.zx, vec2(0.0, 0.0))*5.0-24.5, 0.0, 1.0);
        
        gl_FragColor = vec4(depthColor * uOpacity, 1.0);
      }
    </p>
    <!-- vec3 sideColor = depthColor * (min(abs(vPosition.x*0.2), 1.0) * -1.0 + 1.0); -->
    <script type="module" src="/src/main.js"></script>
  </body>
</html>